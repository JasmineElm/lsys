"""L-System Functions
"""
import random
from math import cos, sin, radians
import re


def set_lsys_string(axiom, rules, n, max_length=1000):
    """
    Generates a string of characters based on the axiom and rules.

    Parameters:
    axiom (str):    The starting string.
    rules (dict):   A dictionary of rules to apply to the string.
    n (int):        The number of iterations to perform.

    Returns:
    str: A string of characters generated by applying the rules to the axiom.
    """
    string = axiom
    # valid = False
    length = 0
    string = "".join([rules.get(c, c) for c in string])
    length = len(string)
    if length < max_length and is_valid_rule(string):
        return string*n
    else:  # raise an error and exit
        print(f"Invalid rule: {string}")


def lsys_to_lines(lsys, start_xy, angle, length, angle_offset):
    """
    Generates a list of lines from a string of characters.

    Parameters:
    lsys (str):             The string of characters to convert to lines.
    start_xy (tuple):       The starting coordinates of the lines.
    angle (float):          The angle of the lines.
    length (float):         The length of the lines.
    angle_offset (float):   The angle offset to apply to the lines.

    Returns:
    list: A list of lines generated from the string of characters.
    """
    lines = []
    stack = []
    x, y = start_xy
    # iterate over lsys, if we encounter an F, check how many subsequent F's
    # are found and draw a single line between the start and end
    for c in lsys:
        # if c == "F" and lsys[lsys.index(c) + 1] != "F":
        #     x2 = x - length * cos(radians(angle))
        #     y2 = y - length * sin(radians(angle))
        #     lines.append(((x, y), (x2, y2)))
        #     x, y = x2, y2
        if c == "F" and lsys[lsys.index(c) + 1] == "F":
            count = 1
            while lsys[lsys.index(c) + count] == "F":
                count += 1
            x2 = x - length * count * cos(radians(angle))
            y2 = y - length * count * sin(radians(angle))
            lines.append(((x, y), (x2, y2)))
            x, y = x2, y2
        elif c == "+":
            angle += angle_offset
        elif c == "-":
            angle -= angle_offset
        elif c == "[":
            stack.append((x, y, angle))
        elif c == "]":
            x, y, angle = stack.pop()
        elif c == "X":
            pass
    return set(lines)


def cleanse_rule(rule_string):
    """replaces cancelling characters in a rule string
    ensures that the rule string will produce a logical
    result when applied to the axiom

    Args:
        rule_string (string): a string of characters

    Returns:
        rule_string (string): a string of characters without cancelling
        sequences of characters
    """

    # Remove unnecessary characters with a single regular expression
    # invalid combinations:
    # [] - push followed by pop
    # +- - left followed by right
    # -+ - right followed by left
    # ][ - pop followed by push
    # [[ - push followed by push
    # ]] - pop followed by pop
    print(f"initial rule_string: {rule_string}")
    rule_string = re.sub(r"\[\]|\+-|-+\|\]\[|\[\[|\]\]", "", rule_string)
    print(f"final rule_string: {rule_string}")
    return rule_string


def is_valid_rule(rule_string):
    """checks if a rule string is valid"""
    # if no F directive, return False
    if "F" not in rule_string:
        return False
    if rule_string == "F" * len(rule_string):
        return False
    # if no + or - directive, return False
    if "+" not in rule_string and "-" not in rule_string:
        return False
    return True


def create_rule_dict(axiom, length):
    """creates a dictionary of rules for an L-System"""
    directives = ["F", "+", "-", "[", "]"]
    # extend directives to include axiom if not already present
    for char in axiom:
        if char not in directives:
            directives.append(char)
    rules = {}
    for char in axiom:
        rules[char] = "F"
        stack = []
        for _ in range(length):
            character = random.choice(directives)
            if character == "[":
                stack.append(character)
            if character == "]":
                if stack:
                    stack.pop()
                # if characcter is in Axiom, and is not F, remove it from
                # directives
                if character in axiom and character != "F":
                    directives.remove(character)
                else:
                    character = ""
            rules[char] += character
        # remove unmatched brackets
        while stack:
            rules[char] = rules[char].rpartition("[")[0]
            stack.pop()
        rules[char] = cleanse_rule(rules[char])
    return rules


# def explain_rules(rules):
#     """returns a string explaining the rules of an L-System"""
#     directives = {
#         "F": "draw",
#         "+": "turn left",
#         "-": "turn right",
#         "[": "save position",
#         "]": "restore position",
#     }
#     if len(rules) > 1:
#         for key in rules:
#             for char in rules[key]:
#                 if char not in directives:
#                     rules[key] = rules[key].replace(char, rules[char])
#     explanation = ""
#     for key in rules:
#         # build the directives string
#         explanation += (
#             f"{key} -> {rules[key]} \n"
#             + "\n".join([directives[char] for char in rules[key]])
#             + "\n"
#         )
#         return explanation


# def expand_rules():
#     """Flattens the rules dictionary into a single string"""
#     directives = ["F", "+", "-", "[", "]"]
#     rule = directives
#     return rule  # placeholder while I figure this out


# def rule_to_filename(rule):
#     """converts a dictionary of rules to a filename string"""
#     # take a dictionary of rules and convert it to a filename
#     # e.g., {'F': 'x+Fy-xy-Fy', 'x': 'F+yx+', 'y': 'xx--[y-]xF-F'}
#     # becomes F_x+Fy-xy-Fy_x_F+yx+_y_xx--[y-]xF-F
#     fn = ""
#     for key in rule:
#         fn += f"{key}_{rule[key]}_"
#     return fn[:-1]


def set_axiom(length):
    """returns a random axiom string"""
    axiom = "F"
    length = random.randint(1, length)
    letters = "xyzabcde"
    length = random.randint(1, length)
    if length > 1:
        axiom += letters[:length]
    return axiom
